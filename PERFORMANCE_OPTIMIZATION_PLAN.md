# 实体识别系统性能优化方案

## 一、性能瓶颈分析

### 1. LLM调用开销（最关键）
- **问题**：每个文本块需要调用两次LLM（实体识别 + 关系提取）
- **影响**：占总处理时间的60-80%
- **优化潜力**：30-50%

### 2. 同步I/O操作
- **问题**：JSON文件写入是同步的，阻塞处理流程
- **影响**：占总处理时间的10-15%
- **优化潜力**：10-20%

### 3. Neo4j数据库写入
- **问题**：每次写入都需要网络请求，虽然有批量操作但仍有延迟
- **影响**：占总处理时间的5-10%
- **优化潜力**：5-10%

### 4. 缓存机制
- **问题**：缓存命中率可能不高，重复计算较多
- **影响**：占总处理时间的5-10%
- **优化潜力**：10-15%

### 5. 并发控制
- **问题**：队列大小限制（maxsize=100）可能限制了并发性能
- **影响**：中等
- **优化潜力**：10-20%

## 二、优化策略

### 策略1：批量LLM调用（高优先级）
**目标**：减少LLM API调用次数，提升30-50%性能

**实施方案**：
1. 收集所有文本块
2. 批量发送给LLM（使用更高效的prompt格式）
3. 使用轻量级模型进行初步筛选
4. 只对筛选后的文本使用主模型

**代码位置**：`llama/entity_extractor.py` 第375-450行

**预期效果**：
- 速度提升：30-50%
- 准确率影响：<2%（使用轻量级模型筛选）

### 策略2：异步I/O操作（中优先级）
**目标**：使用异步文件写入，提升10-20%性能

**实施方案**：
1. 使用asyncio进行异步文件操作
2. 实现批量写入缓冲
3. 使用单独的I/O线程

**代码位置**：`llama/entity_extractor.py` 第284-330行

**预期效果**：
- 速度提升：10-20%
- 准确率影响：0%

### 策略3：优化Neo4j批量写入（中优先级）
**目标**：使用更大的批量大小，提升5-10%性能

**实施方案**：
1. 增加批量写入的大小（从当前的单个节点增加到批量）
2. 使用Neo4j的批量API
3. 实现写入队列

**代码位置**：`llama/entity_extractor.py` 第412-443行

**预期效果**：
- 速度提升：5-10%
- 准确率影响：0%

### 策略4：改进缓存机制（中优先级）
**目标**：提高缓存命中率，提升10-15%性能

**实施方案**：
1. 优化缓存键的生成策略
2. 增加缓存容量
3. 实现多级缓存（内存 + 磁盘）
4. 使用LRU缓存策略

**代码位置**：`llama/llm_cache_manager.py`

**预期效果**：
- 速度提升：10-15%
- 准确率影响：0%

### 策略5：优化并发控制（低优先级）
**目标**：调整队列大小和并发参数，提升10-20%性能

**实施方案**：
1. 增加队列大小（从100增加到500）
2. 优化工作线程数
3. 实现动态调整机制

**代码位置**：`llama/entity_extractor.py` 第354行

**预期效果**：
- 速度提升：10-20%
- 准确率影响：0%

## 三、实施计划

### 阶段1：快速优化（预期提升20-30%）
1. 实施策略4：改进缓存机制
2. 实施策略5：优化并发控制
3. 实施策略3：优化Neo4j批量写入

**时间**：1-2小时
**风险**：低

### 阶段2：深度优化（预期再提升20-30%）
1. 实施策略2：异步I/O操作
2. 实施策略1：批量LLM调用

**时间**：3-4小时
**风险**：中

## 四、性能测试方案

### 测试指标
1. **处理速度**：每秒处理的文本块数
2. **总耗时**：处理N个文本块的总时间
3. **准确率**：实体识别和关系提取的准确率
4. **内存使用**：峰值内存占用
5. **缓存命中率**：缓存命中的百分比

### 测试数据集
- 小规模：10个文本块
- 中规模：50个文本块
- 大规模：100个文本块

### 测试方法
1. 基准测试：优化前的性能
2. 优化测试：优化后的性能
3. 对比分析：计算提升百分比

## 五、风险控制

### 准确率保障
1. 在优化前后使用相同的测试数据集
2. 对比优化前后的实体识别结果
3. 确保准确率下降不超过3%

### 回滚机制
1. 保留优化前的代码版本
2. 如果准确率下降超过3%，立即回滚
3. 记录所有优化变更，便于回滚

### 监控机制
1. 实时监控处理速度
2. 实时监控准确率
3. 实时监控内存使用
4. 异常报警机制

## 六、预期成果

### 性能提升
- 阶段1：20-30%
- 阶段2：再提升20-30%
- 总计：40-60%

### 准确率
- 下降：<3%
- 保持：>95%

### 稳定性
- 内存使用：<500MB
- 错误率：<1%

## 七、后续优化方向

1. **模型优化**：使用更快的LLM模型
2. **硬件优化**：使用GPU加速
3. **分布式处理**：实现分布式处理架构
4. **增量处理**：实现增量更新机制
5. **预训练模型**：使用专门训练的实体识别模型